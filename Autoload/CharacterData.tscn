[gd_scene load_steps=2 format=2]

[sub_resource type="GDScript" id=1]
script/source = "extends Node

\"\"\"
Stores inventory, quests, etc. All the data associated with the PC.
This is intended to be pickled *in entirety*.
\"\"\"

signal item_got (id, amount)
signal karma_got (id, xp)

####################
# KARMA
####################

var karma = {
		\"StateOfSugar\": 190,
		\"Brutality\": 17,
		\"Trickery\": 11,
	}
	
# Functions return how much the karma value changed... I guess?
# TODO this needs to be worked out into a proper animation
# The entire system of representing a karma with XP only is pretty inconvenient
func add_xp(id:String, amount:int, verbose=true):
	if karma.has(id):
		karma[id] += amount
	else:
		karma[id] = amount
	if verbose:
		emit_signal(\"karma_got\", id, amount)
		var popup = preload(\"res://Autoload/WorldspaceHUD/KarmaGet.tscn\").instance()
		$\"/root\".add_child(popup)
		popup.render(id, amount)
		return popup
		
func add_levels(id:String, amount:int, verbose=true):
	if amount < 0:
		printerr(\"Trying to add negative levels\")
		return
	if amount == 0:
		if verbose:
			emit_signal(\"karma_got\", id, amount)
			var popup = preload(\"res://Autoload/WorldspaceHUD/KarmaGet.tscn\").instance()
			$\"/root\".add_child(popup)
			popup.render(id, amount)
			return popup
		return
	if amount > 0:
		add_xp(id, 0) # to initialize
		var xp_curve = KarmaItem.load_by_id(id).xp_curve(karma[id])
		var to_next = xp_curve[\"to_next\"]
		var remain  = xp_curve[\"remain\"]
		if amount > 0:
			add_levels(id, amount-1)
		else:
			add_xp(id, to_next - remain)
			
func bring_up_to_level(id:String, amount:int, verbose=true):
	add_xp(id, 0) # to initialize
	var current_level = KarmaItem.load_by_id(id).xp_curve(karma[id])[\"level\"]
	if current_level >= amount:
		return
	karma.erase(id)
	add_levels(id, amount)
	if verbose:
		emit_signal(\"karma_got\", id, amount)
		var popup = preload(\"res://Autoload/WorldspaceHUD/KarmaGet.tscn\").instance()
		$\"/root\".add_child(popup)
		popup.render(id, amount)
		return popup
	
func get_levels(id:String):
	if karma.has(id):
		return KarmaItem.load_by_id(id).xp_curve(karma[id])[\"level\"]
	else:
		return 0
		
func is_enough_levels(id:String, amount:int):
	add_xp(id, 0) # to initialize
	var current_level = KarmaItem.load_by_id(id).xp_curve(karma[id])[\"level\"]
	return current_level >= amount
	
	
func remove_levels(id:String, amount:int):
	add_xp(id, 0) # to initialize
	var current_level = KarmaItem.load_by_id(id).xp_curve(karma[id])[\"level\"]
	var current_xp    = KarmaItem.load_by_id(id).xp_curve(karma[id])[\"remain\"]
	var target_level  = current_level - amount
	karma.erase(id)
	if target_level < 0:
		return
	add_levels(id, target_level)
	add_xp(id, current_xp)
	
####################
# INVENTORY
####################
		
var items:Dictionary = {} # ID -> amount
var equipped:Dictionary = {} # Equipment slot -> ID

var equipment_slots = [
	\"Head\", \"Chest\", \"Main\", \"Off\", \"Gloves\", \"Lapel\", \"Pants\", \"Shoes\", \"Neck\", 
	\"Ring1\",\"Ring2\",
	\"Accessory1\",\"Accessory2\",\"Accessory3\",\"Accessory4\",\"Accessory5\"
]

func try_equip(id:String, slot:String):
	if !equipment_slots.has(slot):
		printerr(\"No such slot exists: %s\" % slot)
		return
	if InventoryItem.load_by_id(id).equipment_slot != slot_type(slot):
		print(\"Can't equip into this slot\")
		return
	unequip(slot)
	equip(id, slot)
	
func equip(id:String, slot:String):
	equipped[slot] = id
	
func unequip(slot:String):
	equipped.erase(slot)
	
func is_equipped(id:String)->bool:
	for slot in equipped.keys():
		if equipped[slot] == id:
			return true
	return false
	
static func is_equippable(current_item, slot:String):
	return current_item.equipment_slot == slot_type(slot)

static func slot_type(slot:String)->String:
	if [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"0\"].has(slot[slot.length()-1]):
		return slot_type(slot.substr(0,slot.length()-1))
	return slot

func add_item(id:String, number:int = 1, verbose=true):
	if items.has(id):
		items[id] += number
	else:
		items[id] = number
	if verbose:
		emit_signal(\"item_got\", id, number)
		var popup = preload(\"res://Autoload/WorldspaceHUD/ItemGet.tscn\").instance()
		$\"/root\".add_child(popup)
		popup.render(id, number)
		return popup
	
func remove_item(id:String, number:int = -1):
	if not items.has(id):
		printerr(\"Warning: trying to remove a nonexistent item: %s\" % id)
		return
	items[id] -= number
	if items[id] <= 0 or number == -1:
		items.erase(id)
		var todelete = null
		for key in equipped.keys():
			if id == equipped.get(key):
				todelete = key
				break
		if todelete != null:
			unequip(todelete)
	
func has_item(id:String, number:int = 1)->bool:
	if not items.has(id):
		return false
	return items[id] >= number
		
func _ready():
	self.items = {
		\"CoolHat\": 5,
		\"FortuneCookie\": 1,
		\"BlahBlah\": 88
		}
	self.equipped = {
		\"Head\": \"CoolHat\",
		\"Lapel\": \"ErrorItem\"
		}
	#connect(\"item_got\", "

[node name="CharacterData" type="Node"]
script = SubResource( 1 )
