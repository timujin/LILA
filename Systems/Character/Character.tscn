[gd_scene load_steps=6 format=2]

[sub_resource type="GDScript" id=1]
script/source = "extends Node

\"\"\"
Stores inventory, quests, etc. All the data associated with the PC.
This is intended to be deserialized into a save file *in entirety*.
\"\"\"

#onready var inventory = get_node(\"Inventory\")
#onready var karma = get_node(\"Karma\")
onready var pickles = get_node(\"Pickles\")
onready var variables = get_node(\"Variables\")

# Add Journal entities: quests, map, notes, etc...
"

[sub_resource type="GDScript" id=2]
script/source = "extends Node

\"\"\" 
Player's items. Currently tracks:
	
1) Species and amount
2) Equipment

Yet to track:
	
3) Sorting

Need to add the \"subscene to spawn\" to Items and Karmas.
The scene can be arbitrarily pickled and unpickled; and return arbitrary substitutions
instead of name\\\\icon\\\\etc
\"\"\"

var entries = []

func _ready():
	pass
	#add_item(\"GOEEsNote\", 1)
	#add_item(\"Lockpick\", 5)
	#add_item(\"Knife\", 5)
	#add_item(\"Hat\", 1)
	#add_item(\"DifferentHat\", 1)

func fetch_item(id:String):
	\"\"\"Loads an item by ID. If there is no such item, one is created\"\"\"
	if id != \"MissingNo\":
		for item in entries:
			if item.is_id(id):
				return item
				
	var n = InventoryEntry.new(id)
	entries.append(n)
	return n
	
\"Adding and removal\"
	
func add_item(id:String, amount:int):
	var item = fetch_item(id)
	item.add_items(amount)
	clear_empty()
	return item
	
func bring_up_to_amount(id:String, amount:int):
	var item = fetch_item(id)
	item.bring_up_to_amount(amount)
	clear_empty()
	return item
	
func remove_item(id:String, amount:int):
	var item = fetch_item(id)
	if amount == -1:
		item.amount = 0
	else:
		item.remove_items(amount)
	clear_empty()
	
func has_item(id:String, amount:int = -1):
	var item = fetch_item(id)
	if amount == -1:
		return item.amount > 0
	else:
		return item.amount >= amount
	
func clear_empty():
	var res = []
	for item in entries:
		if item.amount == 0:
			pass
		else:
			res.append(item)
	entries = res
	
\"Equipment\"

func what_is_equipped_in_slot(slot:String):
	for item in entries:
		if item.equipped == slot:
			return item
	return null
	
func clear_equipment_slot(slot:String):
	for item in entries:
		if item.species.equipment_slot == slot:
			item.equipped = false
	
func equip_in_slot(id:String, slot:String):
	clear_equipment_slot(slot)
	for item in entries:
		if item.is_id(id):
			item.equipped = true
			return
	printerr(\"Attempt to equip nonexistent item!\")
	
	
func item_get(id:String, amount:int = 1):
	var species = add_item(id, amount).species
	var popup = preload(\"res://Systems/WorldspaceMenus/Popups/ItemGet.tscn\").instance()
	$\"/root/Room\".add_child(popup)
	popup.render(species, amount)
	return popup
"

[sub_resource type="GDScript" id=3]
script/source = "extends Node

var entries = []

func _ready():
	add_xp(\"BlessedByTheGoddess\", 17)
	add_xp(\"Brutality\", 2)

func fetch_karma(id:String):
	# Loads an item by ID. If there is no such karma item, one is created
	
	for item in entries:
		if item.is_id(id):
			return item
	var n = KarmaItemEntry.new(id)
	entries.append(n)
	return n
	
func add_xp(id:String, amount:int):
	var item = fetch_karma(id)
	item.add_xp(amount)
	clear_empty_karma()
		
func add_levels(id:String, amount:int):
	var item = fetch_karma(id)
	item.add_levels(amount)
	clear_empty_karma()
			
func bring_up_to_level(id:String, amount:int):
	var item = fetch_karma(id)
	item.bring_up_to_level(amount)
	clear_empty_karma()
	
func get_levels(id:String):
	var item = fetch_karma(id)
	var res = item.level
	clear_empty_karma()
	return res
		
func is_enough_levels(id:String, amount:int):
	var item = fetch_karma(id)
	var res = item.is_enough_levels(amount)
	clear_empty_karma()
	return res
	
func drain_levels(id:String, amount:int):
	var item = fetch_karma(id)
	item.drain_levels(amount)
	clear_empty_karma()
	
func clear_empty_karma():
	var res = []
	for item in entries:
		if item.level == 0 and item.xp == 0:
			pass
		else:
			res.append(item)
	entries = res
	
"

[sub_resource type="GDScript" id=4]
script/source = "extends Node

\"\"\"
Stores generic global variables. 
Used for event flags, storyline control, etc.
All the things that can't be represented elsewhere.
Should use serializable types - preferably Strings, Ints, Bools, etc.
\"\"\"

signal value_changed(key, old_value, new_value)

export var default_values:Dictionary = {}

var values:Dictionary = {}

func set_value(key:String, value):
	var old = get_value(key)
	values[key] = value
	emit_signal(\"value_changed\", key, old, value)
	
func get_value(key:String, default=null):
	if values.has(key):
		return values[key]
	else:
		if default_values.has(key):
			return default_values[key]
		else:
			return default
		
"

[sub_resource type="GDScript" id=5]
script/source = "extends Node

var pickled_rooms:Dictionary = {}

func pickle(roomid:String, nodepath:NodePath, data:Dictionary):
	if not pickled_rooms.has(roomid):
		pickled_rooms[roomid] = {}
	pickled_rooms[roomid][nodepath] = data
	print(\"Pickled: %s - %s - %s\" % [roomid, nodepath, str(data)])
	
	
	
func unpickle(roomid:String, nodepath:NodePath, default:Dictionary):
	if not pickled_rooms.has(roomid):
		return default
	if not pickled_rooms[roomid].has(nodepath):
		return default
	return pickled_rooms[roomid][nodepath]

"

[node name="Character" type="Node"]
script = SubResource( 1 )

[node name="Inventory--" type="Node" parent="."]
script = SubResource( 2 )

[node name="Karma--" type="Node" parent="."]
script = SubResource( 3 )

[node name="Variables" type="Node" parent="."]
script = SubResource( 4 )

[node name="Pickles" type="Node" parent="."]
script = SubResource( 5 )
